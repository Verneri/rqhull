#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
/* automatically generated by rust-bindgen */

struct SetIter{
    facetp: *mut *mut libc::c_void
}

impl SetIter {

    fn new(set:*mut setT) -> SetIter {
        if set.is_null() {
            SetIter{facetp: std::ptr::null_mut()}

        } else {
            unsafe {
                SetIter{facetp: (&mut (*set).e[0].p) as *mut *mut libc::c_void}
            }
        }

    }

}

impl Iterator for SetIter {
    type Item = facetT;

       fn next(&mut self) -> Option<facetT> {

           unsafe {

               if !self.facetp.is_null() && !(*self.facetp).is_null() {
                   let facet = *self.facetp as *mut facetT;
                   self.facetp = self.facetp.offset(1);
                   Some(*facet)
               } else {
                   None
               }

           }
    }
}


#[cfg(test)]
#[macro_use]
extern crate ndarray;
#[cfg(not(test))]
extern crate ndarray;

extern crate itertools;
extern crate libc;


use itertools::Itertools;



use ndarray::{Array1, Array2};

use std::mem;
use std::ffi::CString;
use std::os::raw::c_int;


enum QhullMode {
    Voronoi

}

enum QhullOption {
    ScaleLast,
    KeepCoplanar,
    AddAPointAtInfinity,
    ExactPreMerges
}


fn option_strings(option: QhullOption) -> String {
    match option {
        QhullOption::ScaleLast => "Qbb",
        QhullOption::KeepCoplanar => "Qc",
        QhullOption::AddAPointAtInfinity => "Qz",
        QhullOption::ExactPreMerges => "Qx"
    }.to_owned()

}

extern { fn err() -> *mut FILE;}

struct QHull<'a>{
    qh: *mut qhT,
    points:  &'a mut Array2<f64>
}

#[derive(Debug)]
pub struct QhullError{
 pub external_fuction:String,
 pub error_code:c_int
}

impl QhullError {

    fn new(ef: &str, ec:c_int) -> QhullError {
        QhullError {
            external_fuction: ef.to_owned(),
            error_code: ec
        }
    }

}

struct VoronoiData {

    nridges: c_int,
    ridge_points: Vec<[i32;2]>,
    ridge_vertices: Vec<Vec<i32>>

}

impl<'a> QHull<'a> {


    fn new(mode:QhullMode, points: &mut Array2<f64>, options: Vec<QhullOption>) -> Result<QHull,QhullError> {
        if points.shape()[0] <= 0 {
            panic!("no points given");
        }
        if points.shape()[1]<2 {
            panic!("points  need to be at least 2D. current amount of dimension is {}", points.shape()[1])
        }


        let final_options = QHull::qhull_options(mode, options);


        unsafe {

            let qh_ptr: *mut qhT = libc::malloc(mem::size_of::<qhT>() as libc::size_t) as *mut qhT;
            if qh_ptr.is_null() {
                panic!("failed to allocate memory");
            }

            let qh = QHull{qh: qh_ptr, points};


            qh_zero(qh.qh, err());

            let exit_code =qh_new_qhull(qh.qh,
                         qh.points.shape()[1] as c_int,
                         qh.points.shape()[0] as c_int,
                         qh.points.as_mut_ptr(),
                         0,
                         final_options.into_raw(),
                         std::ptr::null_mut::<FILE>(),
                         err());

            if exit_code != 0 {
                Err(QhullError::new("qh_new_qhull",exit_code))?
            }

            let result = qh;

            Ok(result)



        }




    }

    fn qhull_options(mode: QhullMode, options: Vec<QhullOption>) -> CString {

        let mode_option = match mode {
            QhullMode::Voronoi => "v"

        };

        let option_str = options.into_iter().map(option_strings).join(" ");
        CString::new(format!("qhull {} {}", mode_option, option_str)).unwrap()

    }



    fn get_vornoi_diagram(&self) -> (Vec<[f64; 2]>, Vec<[i32; 2]>, Vec<Vec<i32>>, Vec<Vec<i32>>, Array1<i32>) {
        let mut dist:f64 = 0.0;

        let mut data = VoronoiData {
            nridges: 0,
            ridge_points: Vec::with_capacity(10),
            ridge_vertices: Vec::new()
        };

        unsafe {

            qh_eachvoronoi_all(self.qh, &mut data as *mut VoronoiData as *mut FILE, Some(QHull::visit_voronoi), (*self.qh).UPPERdelaunay, qh_RIDGE_qh_RIDGEall, 1);

        }

        let mut regions:Vec<Vec<i32>> = Vec::new();

        let mut point_region = unsafe {Array1::<c_int>::uninitialized(self.points.shape()[0])};
        point_region.fill(-1);


        let mut vertex = unsafe {
            let vertex = (*self.qh).vertex_list;
            if vertex.is_null() {panic!("null vertex encountered")};
            &mut *vertex
        };

        while  !vertex.next.is_null() {
            unsafe {
                QHull::qh_order_vertexneighbors_nd(self.qh, (self.points.shape()[1]+1) as c_int, vertex);
                let i = qh_pointid(self.qh, vertex.point);
                if i < self.points.shape()[0] as c_int {
                    point_region[i as usize] = regions.len() as c_int;
                }
                let mut inf_seen = false;

                let mut current_region:Vec<i32> = Vec::new();

                for neighbor in SetIter::new(vertex.neighbors) {
                    let i = (neighbor.visitid as c_int - 1) as c_int;
                    if i == -1 {
                        if !inf_seen  {
                            inf_seen = true;
                        } else {
                            continue
                        }
                    }
                    current_region.push (i)

                }

                if current_region.len() == 1 && *current_region.first().unwrap() == -1  {
                    current_region = Vec::new();
                }

                regions.push(current_region);

                vertex = &mut *vertex.next

            }



        }



        let mut nvoronoi_vertices = 0 as usize;
        let mut vv = Vec::<[f64;2]>::with_capacity(10);
        let mut vor_ptr = vv.as_mut_ptr();
        let mut cap = vv.capacity();
        use std::mem;

        mem::forget(vv);


        let mut facet_ptr = unsafe {
            (*self.qh).facet_list
        };



        while !facet_ptr.is_null() && unsafe {!(*facet_ptr).next.is_null()} {
            let facet = unsafe{&mut *facet_ptr};
            if facet.visitid > 0 {
                let center = unsafe {qh_facetcenter(self.qh, facet.vertices)};
                use std::cmp::max;
                nvoronoi_vertices = max(facet.visitid as usize, nvoronoi_vertices);
                if nvoronoi_vertices >= cap {
                    let mut tempv = unsafe{Vec::from_raw_parts(vor_ptr, cap, cap)};
                    tempv.reserve(nvoronoi_vertices + 1);
                    vor_ptr = tempv.as_mut_ptr();
                    cap = tempv.capacity();
                    mem::forget(tempv);
                }
                let vertice = unsafe{vor_ptr.offset((facet.visitid-1) as isize)} as *mut f64;
                for k in 0..self.points.shape()[1] {
                    let coord = unsafe{*(center.offset(k as isize))};
                    unsafe{(*vertice.offset(k as isize)) = coord};
                }
                unsafe{qh_memfree(self.qh, center as *mut ::std::os::raw::c_void, (*self.qh).center_size)};
                if !facet.coplanarset.is_null() {
                    let set_size = unsafe{qh_setsize(self.qh, facet.coplanarset)};
                    for k in 0..set_size {
                        let coplanarset = unsafe{&*facet.coplanarset};
                        println!("{} set {} len", set_size,coplanarset.e.len());

                        let point = unsafe {&mut *(coplanarset.e[k as usize].p as *mut f64)};
                        let vertex = unsafe{&*(qh_nearvertex(self.qh, facet, point, &mut dist))};
                        let i = unsafe{qh_pointid(self.qh, point) as usize};
                        let j = unsafe{qh_pointid(self.qh, vertex.point) as usize};
                        if i < self.points.shape()[0] {
                            point_region[i] = point_region[j];
                        }


                    }


                }

            }
            facet_ptr = facet.next

        }

        (unsafe{Vec::from_raw_parts(vor_ptr, nvoronoi_vertices, cap)}, data.ridge_points, data.ridge_vertices, regions, point_region)



    }


    fn qh_order_vertexneighbors_nd(qh: *mut qhT, nd: c_int,  vertex: *mut vertexT) {
        if nd == 3 {
            unsafe {qh_order_vertexneighbors(qh, vertex)}
        } else if nd >= 4 {
            unsafe {
                qsort((*(*vertex).neighbors).e[0].p, qh_setsize(qh, (*vertex).neighbors) as usize,
                      mem::size_of::<facetT>(), Some(qh_compare_facetvisit))
            }


        }



    }





    unsafe extern "C" fn visit_voronoi(qh: *mut qhT,
                                       fp: *mut FILE,
                                       vertex: *mut vertexT,
                                       vertexA: *mut vertexT,
                                       centers: *mut setT,
                                       _: ::std::os::raw::c_uint) {

        let data = &mut *(fp as *mut VoronoiData);

        let point1 = qh_pointid(qh, (*vertex).point);
        let point2 = qh_pointid(qh, (*vertexA).point);

        data.ridge_points.push([point1,point2]);


        let current_vertices = SetIter::new(centers).map(|f| f.visitid as i32 -1).collect::<Vec<i32>>();

        data.ridge_vertices.push(current_vertices);

        data.nridges += 1;

    }

}


impl<'a> Drop for QHull<'a> {
    fn drop(&mut self) {
        if !self.qh.is_null() {
            let mut curlong: ::std::os::raw::c_int = 1;
            let mut totlong: ::std::os::raw::c_int = 1;
            unsafe {
                qh_freeqhull(self.qh, qh_ALL);
                qh_memfreeshort(self.qh, &mut curlong, &mut totlong);

                libc::free(self.qh as *mut libc::c_void);
            }


        }

    }
}



pub struct Voronoi{
    pub points : Array2<f64>,
    pub vertices: Vec<[f64;2]>,
    pub ridge_points:Vec<[i32;2]>,
    pub ridge_vertices: Vec<Vec<i32>>,
    pub regions: Vec<Vec<i32>>,
    pub point_region: Array1<i32>
}



impl Voronoi {




    pub fn new(mut points: Array2<f64>) -> Result<Voronoi,QhullError> {



        let mut options = vec![QhullOption::ScaleLast, QhullOption::KeepCoplanar, QhullOption::AddAPointAtInfinity];

        if points.shape()[1] >= 5 {
            options.push(QhullOption::ExactPreMerges);
        }


        let (vertices,
            ridge_points,
            ridge_vertices,
            regions,
            point_region) = {
            let qh = QHull::new(QhullMode::Voronoi, &mut points, options)?;
            qh.get_vornoi_diagram()
        };

        Ok(
           Voronoi {
               points: points,
               vertices: vertices,
               ridge_points: ridge_points,
               ridge_vertices: ridge_vertices,
               regions: regions,
               point_region: point_region
           }
        )

    }


}


#[cfg(test)]
mod tests;
